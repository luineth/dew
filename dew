#!/usr/bin/awk -f

# USAGE: pipe your to.dew list to this executable. If the .vim files are
# installed, use <leader>f from within a .dew file, or, run :%! path/to/dew
# to filter in place.

BEGIN {
    # grab today's date YYYYMMDD
    "date +%F" | getline today
    close("date +%F")

    date_regex = "[0-9]{4}-[0-9]{2}-[0-9]{2}"
    cron_regex = "{([,-/*0-9]+ ){2}[L#,-/*0-9]+}"
    repeat_regex = "{[0-9]+}"
}

# skip stray one-character lines
/^\S\s*$/ { next }

# skip machine comments
/^:/ { next }

# strip leading and trailing whitespace
{
    sub(/^[ \t]+/, "", $0)
    sub(/[ \t]+$/, "", $0)
}


# trim multiple blank lines
!NF {
    if (prev_line_is_blank) next
    prev_line_is_blank =1
}

NF {
    prev_line_is_blank = 0
}

# directly cache to inbox and someday to their respective output sections
/^\?/ { output["inbox"][++output_n["inbox"]] = $0; next }
/^&/ { output["someday"][++output_n["someday"]] = $0; next }

/^#/   { header[++header_n] = $0; next }

# handle cron-like repeats
# {* * *} syntax, omitting hours and minutes
$0 ~ cron_regex && /^~.*[^~]$/ {
    match($0, cron_regex)
    cron_string = substr($0, RSTART, RLENGTH)
    gsub(/[{}]/, "", cron_string)

    done[++done_n] = $0 "~" # store inactivated line

    sub(/^~/, "$", $0)
    gsub(date_regex, "", $0)

    new_date = cron_offset(today, "0 0 " cron_string)
    if (new_date != "0") {
        $0 = $0 " " new_date
    } else {
        $0 = $0 "\n:!CRON ERROR"
    }
    scheduled[++scheduled_n] = $0
    next
}

# handle simple repeats
# {#} syntax, integer with number of days frequency
$0 ~ repeat_regex && /^~.*[^~]$/ {
    match($0, repeat_regex)
    repeat_string = substr($0, RSTART, RLENGTH)
    gsub(/[{}]/, "", repeat_string)

    done[++done_n] = $0 "~" # store inactivated line

    sub(/^~/, "$", $0)
    gsub(date_regex, "", $0)

    new_date = date_offset(today, repeat_string)
    $0 = $0 " " new_date
    scheduled[++scheduled_n] = $0
    next
}


/^~/    { done[++done_n] = $0; next }

# prepend "> " to any due reminder dates,
$0 ~ date_regex {
    match($0, date_regex)
    date_string = substr($0, RSTART, RLENGTH)

    if(date_string <= today)
        sub(/^[\$%]/, ">", $0) # only activate due $ or %
}

# record contexs from workable tasks
/^>.*@.+/ {
    for(i = 1; i <= NF; i++) {
        if(match($i, /^@.+$/)) {
            contexts[$i]++
        }
    }
}

/^>/    { workable[++workable_n] = $0; next }

# lint any scheduled or waiting-for tasks w/o follow up dates
(/^\$/ || /^%/) && $0 !~ date_regex {
    $0 = $0 "\n:! DATE"
}

/^\$/ { scheduled[++scheduled_n] = $0; next }

/^%/ {
    waiting_on[$1]++
    waiting[++waiting_n] = $0
}

# any non-matched items: indented then cached
NF {
    $0 = "  " $0
    blocked[++blocked_n] = $0
    next
    }

# line must be blank to continue:

workable_n {
    blockprint("active")
    next
}

waiting_n || scheduled_n {
    blockprint("inactive")
    next
}

blocked_n {
    blockprint("active", ":! BLOCKED")
    next
}

# only done or headers:
{
    blockprint("completed")
    next
}

function blockprint(section, lint) {
    # store any warning
    if (lint) output[section][++output_n[section]] = lint
    
    # transfer project block to its output section
    for (i = 1; i <= header_n; i++) {
        output[section][++output_n[section]] = header[i]
    }
    for (i = 1; i <= done_n; i++) {
        output[section][++output_n[section]] = done[i]
    }
    for (i = 1; i <= workable_n; i++) {
        output[section][++output_n[section]] = workable[i]
    }
    for (i = 1; i <= waiting_n; i++) {
        output[section][++output_n[section]] = waiting[i]
    }
    for (i = 1; i <= scheduled_n; i++) {
        output[section][++output_n[section]] = scheduled[i]
    }
    for (i = 1; i <= blocked_n; i++) {
        output[section][++output_n[section]] = blocked[i]
    }
    output[section][++output_n[section]] = ""


    # flush project block cache
    delete header
    delete done
    delete workable
    delete waiting
    delete scheduled
    delete blocked
    header_n = done_n = workable_n = waiting_n = scheduled_n = blocked_n = 0
}


END {

    print ": Inbox:", output_n["inbox"]
    print ": Context counts:"
    for (i in contexts)
        print ":\t" i ": " contexts[i]
    printf("\n")

    output_section[1] = "inbox"
    output_section[2] = "active"
    output_section[3] = "inactive"
    output_section[4] = "someday"
    output_section[5] = "completed"

    for( i = 1; i <= 5; i++) {
        sec = output_section[i]
        print ""
        print ": " sec
        for(j = 1; j <= output_n[sec]; j++) {
            print output[sec][j]
        }
    }
}


function cron_offset(date_str, cron_expr,	cmd, result) {
    cmd = "python3 -c '"
    cmd = cmd "from croniter import croniter\n"
    cmd = cmd "from datetime import datetime\n"
    cmd = cmd "import sys\n"
    cmd = cmd "try:\n"
    cmd = cmd "    base = datetime.strptime(\"" date_str "\", \"%Y-%m-%d\")\n"
    cmd = cmd "    itr = croniter(\"" cron_expr "\", base)\n"
    cmd = cmd "    print(itr.get_next(datetime).strftime(\"%Y-%m-%d\"))\n"
    cmd = cmd "except Exception:\n"
    cmd = cmd "    print(\"0\")\n"
    cmd = cmd "'"

	cmd | getline result
	close(cmd)

	return result
}

function date_offset(date_str, offset,  cmd, result) { 
    cmd = "date -d \"" date_str " " ((offset >=0) ? "+" offset : offset) " days\" +%F"

    cmd | getline result
    close(cmd)

    return result
}
#!/usr/bin/awk -f

BEGIN {
    # Grab today's date YYYYMMDD
    "date +%Y%m%d" | getline today
    close("date +%Y%m%d")

    date_regex = "[0-9]{4}-[0-9]{2}-[0-9]{2}"
}

# skip stray one-character lines
/^\S\s*$/ { next }

# skip machine comments
/^:/ { next }

# strip leading and trailing whitespace
{
    sub(/^[ \t]+/, "", $0)
    sub(/[ \t]+$/, "", $0)
}


# Trim multiple blank lines
!NF {
    if (prev_line_is_blank) next
    prev_line_is_blank =1
}

NF {
    prev_line_is_blank = 0
}


/^\?/   { output["inbox"][++output_n["inbox"]] = $0; next }
/^&/    { output["someday"][++output_n["someday"]] = $0; next }

/^#/   { header[++header_n] = $0; next }
/^~/    { done[++done_n] = $0; next }

# prepend "> " to any due reminder dates,
# excluding inactive statuses recorded above^
$0 ~ date_regex {
    match($0, date_regex)
    date_string = substr($0, RSTART, RLENGTH)
    gsub("-", "", date_string) # YYYY-MM-DD to YYYYMMDD

    if(date_string <= today && $0 !~ /^>/) # don't double up on ">"
        $0 = ">" $0
}

# record contexs from workable tasks
/^>.*@.+/ {
    for(i = 1; i <= NF; i++) {
        if(match($i, /^@.+$/)) {
            contexts[$i]++
        }
    }
}

/^>/    { workable[++workable_n] = $0; next }

# lint any scheduled or waiting-for tasks w/o follow up dates
(/^\$/ || /^%/) && $0 !~ /[0-9]{4}-[0-9]{2}-[0-9]{2}/ {
    $0 = $0 "\n:! DATE"
}

/^\$/ { scheduled[++scheduled_n] = $0; next }

/^%/ {
    waiting_on[$1]++
    waiting[++waiting_n] = $0
}

# any non-matched items: indented then cached
NF {
    $0 = "  " $0
    blocked[++blocked_n] = $0
    next
    }

# line must be blank to continue:

workable_n {
    blockprint("active")
    next
}

waiting_n || scheduled_n {
    blockprint("inactive")
    next
}

blocked_n {
    blockprint("active", ":! BLOCKED")
    next
}

# only done or headers:
{
    blockprint("completed")
    next
}

function blockprint(section, lint) {
    # store any warning
    if (lint) output[section][++output_n[section]] = lint
    
    # transfer a project block to its output section
    for (i = 1; i <= header_n; i++) {
        output[section][++output_n[section]] = header[i]
    }
    for (i = 1; i <= done_n; i++) {
        output[section][++output_n[section]] = done[i]
    }
    for (i = 1; i <= workable_n; i++) {
        output[section][++output_n[section]] = workable[i]
    }
    for (i = 1; i <= waiting_n; i++) {
        output[section][++output_n[section]] = waiting[i]
    }
    for (i = 1; i <= scheduled_n; i++) {
        output[section][++output_n[section]] = scheduled[i]
    }
    for (i = 1; i <= blocked_n; i++) {
        output[section][++output_n[section]] = blocked[i]
    }
    output[section][++output_n[section]] = ""


    # flush project block cache
    delete header
    delete done
    delete workable
    delete waiting
    delete scheduled
    delete blocked
    header_n = done_n = workable_n = waiting_n = scheduled_n = blocked_n = 0
}


END {

    print ": Inbox:", output_n["inbox"]
    print ": Context counts:"
    for (i in contexts)
        print ":\t" i ": " contexts[i]
    printf("\n")

    output_section[1] = "inbox"
    output_section[2] = "active"
    output_section[3] = "inactive"
    output_section[4] = "someday"
    output_section[5] = "completed"

    for( i = 1; i <= 5; i++) {
        sec = output_section[i]
        print ""
        print ": " sec
        for(j = 1; j <= output_n[sec]; j++) {
            print output[sec][j]
        }
    }
}
